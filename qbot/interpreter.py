import math
import numpy as np
from qbot.probVal import ProbVal, funcWrapper

allowedNames = {
    # math functions
    "math.acos":      lambda *args, **kwargs: funcWrapper(math.acos, *args, **kwargs),
    "math.acosh":     lambda *args, **kwargs: funcWrapper(math.acosh, *args, **kwargs),
    "math.asin":      lambda *args, **kwargs: funcWrapper(math.asin, *args, **kwargs),
    "math.asinh":     lambda *args, **kwargs: funcWrapper(math.asinh, *args, **kwargs),
    "math.atan":      lambda *args, **kwargs: funcWrapper(math.atan, *args, **kwargs),
    "math.atan2":     lambda *args, **kwargs: funcWrapper(math.atan2, *args, **kwargs),
    "math.atanh":     lambda *args, **kwargs: funcWrapper(math.atanh, *args, **kwargs),
    "math.ceil":      lambda *args, **kwargs: funcWrapper(math.ceil, *args, **kwargs),
    "math.copysign":  lambda *args, **kwargs: funcWrapper(math.copysign, *args, **kwargs),
    "math.cos":       lambda *args, **kwargs: funcWrapper(math.cos, *args, **kwargs),
    "math.cosh":      lambda *args, **kwargs: funcWrapper(math.cosh, *args, **kwargs),
    "math.degrees":   lambda *args, **kwargs: funcWrapper(math.degrees, *args, **kwargs),
    "math.dist":      lambda *args, **kwargs: funcWrapper(math.dist, *args, **kwargs),
    "math.erf":       lambda *args, **kwargs: funcWrapper(math.erf, *args, **kwargs),
    "math.erfc":      lambda *args, **kwargs: funcWrapper(math.erfc, *args, **kwargs),
    "math.exp":       lambda *args, **kwargs: funcWrapper(math.exp, *args, **kwargs),
    "math.expm1":     lambda *args, **kwargs: funcWrapper(math.expm1, *args, **kwargs),
    "math.fabs":      lambda *args, **kwargs: funcWrapper(math.fabs, *args, **kwargs),
    "math.factorial": lambda *args, **kwargs: funcWrapper(math.factorial, *args, **kwargs),
    "math.floor":     lambda *args, **kwargs: funcWrapper(math.floor, *args, **kwargs),
    "math.fmod":      lambda *args, **kwargs: funcWrapper(math.fmod, *args, **kwargs),
    "math.frexp":     lambda *args, **kwargs: funcWrapper(math.frexp, *args, **kwargs),
    "math.fsum":      lambda *args, **kwargs: funcWrapper(math.fsum, *args, **kwargs),
    "math.gamma":     lambda *args, **kwargs: funcWrapper(math.gamma, *args, **kwargs),
    "math.gcd":       lambda *args, **kwargs: funcWrapper(math.gcd, *args, **kwargs),
    "math.hypot":     lambda *args, **kwargs: funcWrapper(math.hypot, *args, **kwargs),
    "math.isclose":   lambda *args, **kwargs: funcWrapper(math.isclose, *args, **kwargs),
    "math.isfinite":  lambda *args, **kwargs: funcWrapper(math.isfinite, *args, **kwargs),
    "math.isinf":     lambda *args, **kwargs: funcWrapper(math.isinf, *args, **kwargs),
    "math.isnan":     lambda *args, **kwargs: funcWrapper(math.isnan, *args, **kwargs),
    "math.isqrt":     lambda *args, **kwargs: funcWrapper(math.isqrt, *args, **kwargs),
    "math.lcm":       lambda *args, **kwargs: funcWrapper(math.lcm, *args, **kwargs),
    "math.ldexp":     lambda *args, **kwargs: funcWrapper(math.ldexp, *args, **kwargs),
    "math.lgamma":    lambda *args, **kwargs: funcWrapper(math.lgamma, *args, **kwargs),
    "math.log":       lambda *args, **kwargs: funcWrapper(math.log, *args, **kwargs),
    "math.log1p":     lambda *args, **kwargs: funcWrapper(math.log1p, *args, **kwargs),
    "math.log10":     lambda *args, **kwargs: funcWrapper(math.log10, *args, **kwargs),
    "math.log2":      lambda *args, **kwargs: funcWrapper(math.log2, *args, **kwargs),
    "math.modf":      lambda *args, **kwargs: funcWrapper(math.modf, *args, **kwargs),
    "math.pow":       lambda *args, **kwargs: funcWrapper(math.pow, *args, **kwargs),
    "math.radians":   lambda *args, **kwargs: funcWrapper(math.radians, *args, **kwargs),
    "math.remainder": lambda *args, **kwargs: funcWrapper(math.remainder, *args, **kwargs),
    "math.sin":       lambda *args, **kwargs: funcWrapper(math.sin, *args, **kwargs),
    "math.sinh":      lambda *args, **kwargs: funcWrapper(math.sinh, *args, **kwargs),
    "math.sqrt":      lambda *args, **kwargs: funcWrapper(math.sqrt, *args, **kwargs),
    "math.tan":       lambda *args, **kwargs: funcWrapper(math.tan, *args, **kwargs),
    "math.tanh":      lambda *args, **kwargs: funcWrapper(math.tanh, *args, **kwargs),
    "math.trunc":     lambda *args, **kwargs: funcWrapper(math.trunc, *args, **kwargs),
    "math.prod":      lambda *args, **kwargs: funcWrapper(math.prod, *args, **kwargs),
    "math.perm":      lambda *args, **kwargs: funcWrapper(math.perm, *args, **kwargs),
    "math.comb":      lambda *args, **kwargs: funcWrapper(math.comb, *args, **kwargs),
    "math.nextafter": lambda *args, **kwargs: funcWrapper(math.nextafter, *args, **kwargs),
    "math.ulp":       lambda *args, **kwargs: funcWrapper(math.ulp, *args, **kwargs),

    #constants
    "math.pi": math.pi,
    "math.e": math.e,
    "math.tau": math.tau,
    "math.inf": math.inf,
    "math.nan": math.nan,

    #np functions
    "np.ndarray":                 lambda *args, **kwargs: funcWrapper(np.ndarray, *args, **kwargs),
    "np.flatiter":                lambda *args, **kwargs: funcWrapper(np.flatiter, *args, **kwargs),
    "np.nditer":                  lambda *args, **kwargs: funcWrapper(np.nditer, *args, **kwargs),
    "np.nested_iters":            lambda *args, **kwargs: funcWrapper(np.nested_iters, *args, **kwargs),
    "np.ufunc":                   lambda *args, **kwargs: funcWrapper(np.ufunc, *args, **kwargs),
    "np.arange":                  lambda *args, **kwargs: funcWrapper(np.arange, *args, **kwargs),
    "np.array":                   lambda *args, **kwargs: funcWrapper(np.array, *args, **kwargs),
    "np.asarray":                 lambda *args, **kwargs: funcWrapper(np.asarray, *args, **kwargs),
    "np.asanyarray":              lambda *args, **kwargs: funcWrapper(np.asanyarray, *args, **kwargs),
    "np.ascontiguousarray":       lambda *args, **kwargs: funcWrapper(np.ascontiguousarray, *args, **kwargs),
    "np.asfortranarray":          lambda *args, **kwargs: funcWrapper(np.asfortranarray, *args, **kwargs),
    "np.zeros":                   lambda *args, **kwargs: funcWrapper(np.zeros, *args, **kwargs),
    "np.count_nonzero":           lambda *args, **kwargs: funcWrapper(np.count_nonzero, *args, **kwargs),
    "np.empty":                   lambda *args, **kwargs: funcWrapper(np.empty, *args, **kwargs),
    "np.broadcast":               lambda *args, **kwargs: funcWrapper(np.broadcast, *args, **kwargs),
    "np.dtype":                   lambda *args, **kwargs: funcWrapper(np.dtype, *args, **kwargs),
    "np.fromstring":              lambda *args, **kwargs: funcWrapper(np.fromstring, *args, **kwargs),
    "np.where":                   lambda *args, **kwargs: funcWrapper(np.where, *args, **kwargs),
    "np.argwhere":                lambda *args, **kwargs: funcWrapper(np.argwhere, *args, **kwargs),
    "np.copyto":                  lambda *args, **kwargs: funcWrapper(np.copyto, *args, **kwargs),
    "np.concatenate":             lambda *args, **kwargs: funcWrapper(np.concatenate, *args, **kwargs),
    "np.lexsort":                 lambda *args, **kwargs: funcWrapper(np.lexsort, *args, **kwargs),
    "np.can_cast":                lambda *args, **kwargs: funcWrapper(np.can_cast, *args, **kwargs),
    "np.promote_types":           lambda *args, **kwargs: funcWrapper(np.promote_types, *args, **kwargs),
    "np.min_scalar_type":         lambda *args, **kwargs: funcWrapper(np.min_scalar_type, *args, **kwargs),
    "np.result_type":             lambda *args, **kwargs: funcWrapper(np.result_type, *args, **kwargs),
    "np.isfortran":               lambda *args, **kwargs: funcWrapper(np.isfortran, *args, **kwargs),
    "np.empty_like":              lambda *args, **kwargs: funcWrapper(np.empty_like, *args, **kwargs),
    "np.zeros_like":              lambda *args, **kwargs: funcWrapper(np.zeros_like, *args, **kwargs),
    "np.ones_like":               lambda *args, **kwargs: funcWrapper(np.ones_like, *args, **kwargs),
    "np.correlate":               lambda *args, **kwargs: funcWrapper(np.correlate, *args, **kwargs),
    "np.convolve":                lambda *args, **kwargs: funcWrapper(np.convolve, *args, **kwargs),
    "np.inner":                   lambda *args, **kwargs: funcWrapper(np.inner, *args, **kwargs),
    "np.dot":                     lambda *args, **kwargs: funcWrapper(np.dot, *args, **kwargs),
    "np.outer":                   lambda *args, **kwargs: funcWrapper(np.outer, *args, **kwargs),
    "np.vdot":                    lambda *args, **kwargs: funcWrapper(np.vdot, *args, **kwargs),
    "np.roll":                    lambda *args, **kwargs: funcWrapper(np.roll, *args, **kwargs),
    "np.rollaxis":                lambda *args, **kwargs: funcWrapper(np.rollaxis, *args, **kwargs),
    "np.moveaxis":                lambda *args, **kwargs: funcWrapper(np.moveaxis, *args, **kwargs),
    "np.cross":                   lambda *args, **kwargs: funcWrapper(np.cross, *args, **kwargs),
    "np.tensordot":               lambda *args, **kwargs: funcWrapper(np.tensordot, *args, **kwargs),
    "np.fromiter":                lambda *args, **kwargs: funcWrapper(np.fromiter, *args, **kwargs),
    "np.array_equal":             lambda *args, **kwargs: funcWrapper(np.array_equal, *args, **kwargs),
    "np.array_equiv":             lambda *args, **kwargs: funcWrapper(np.array_equiv, *args, **kwargs),
    "np.indices":                 lambda *args, **kwargs: funcWrapper(np.indices, *args, **kwargs),
    "np.fromfunction":            lambda *args, **kwargs: funcWrapper(np.fromfunction, *args, **kwargs),
    "np.isclose":                 lambda *args, **kwargs: funcWrapper(np.isclose, *args, **kwargs),
    "np.isscalar":                lambda *args, **kwargs: funcWrapper(np.isscalar, *args, **kwargs),
    "np.binary_repr":             lambda *args, **kwargs: funcWrapper(np.binary_repr, *args, **kwargs),
    "np.base_repr":               lambda *args, **kwargs: funcWrapper(np.base_repr, *args, **kwargs),
    "np.ones":                    lambda *args, **kwargs: funcWrapper(np.ones, *args, **kwargs),
    "np.identity":                lambda *args, **kwargs: funcWrapper(np.identity, *args, **kwargs),
    "np.allclose":                lambda *args, **kwargs: funcWrapper(np.allclose, *args, **kwargs),
    "np.compare_chararrays":      lambda *args, **kwargs: funcWrapper(np.compare_chararrays, *args, **kwargs),
    "np.putmask":                 lambda *args, **kwargs: funcWrapper(np.putmask, *args, **kwargs),
    "np.flatnonzero":             lambda *args, **kwargs: funcWrapper(np.flatnonzero, *args, **kwargs),
    "np.bitwise_not":             lambda *args, **kwargs: funcWrapper(np.bitwise_not, *args, **kwargs),
    "np.full":                    lambda *args, **kwargs: funcWrapper(np.full, *args, **kwargs),
    "np.full_like":               lambda *args, **kwargs: funcWrapper(np.full_like, *args, **kwargs),
    "np.matmul":                  lambda *args, **kwargs: funcWrapper(np.matmul, *args, **kwargs),
    "np.shares_memory":           lambda *args, **kwargs: funcWrapper(np.shares_memory, *args, **kwargs),
    "np.may_share_memory":        lambda *args, **kwargs: funcWrapper(np.may_share_memory, *args, **kwargs),
    "np.all":                     lambda *args, **kwargs: funcWrapper(np.all, *args, **kwargs),
    "np.alltrue":                 lambda *args, **kwargs: funcWrapper(np.alltrue, *args, **kwargs),
    "np.amax":                    lambda *args, **kwargs: funcWrapper(np.amax, *args, **kwargs),
    "np.amin":                    lambda *args, **kwargs: funcWrapper(np.amin, *args, **kwargs),
    "np.any":                     lambda *args, **kwargs: funcWrapper(np.any, *args, **kwargs),
    "np.argmax":                  lambda *args, **kwargs: funcWrapper(np.argmax, *args, **kwargs),
    "np.argmin":                  lambda *args, **kwargs: funcWrapper(np.argmin, *args, **kwargs),
    "np.argpartition":            lambda *args, **kwargs: funcWrapper(np.argpartition, *args, **kwargs),
    "np.argsort":                 lambda *args, **kwargs: funcWrapper(np.argsort, *args, **kwargs),
    "np.around":                  lambda *args, **kwargs: funcWrapper(np.around, *args, **kwargs),
    "np.choose":                  lambda *args, **kwargs: funcWrapper(np.choose, *args, **kwargs),
    "np.clip":                    lambda *args, **kwargs: funcWrapper(np.clip, *args, **kwargs),
    "np.compress":                lambda *args, **kwargs: funcWrapper(np.compress, *args, **kwargs),
    "np.cumprod":                 lambda *args, **kwargs: funcWrapper(np.cumprod, *args, **kwargs),
    "np.cumproduct":              lambda *args, **kwargs: funcWrapper(np.cumproduct, *args, **kwargs),
    "np.cumsum":                  lambda *args, **kwargs: funcWrapper(np.cumsum, *args, **kwargs),
    "np.diagonal":                lambda *args, **kwargs: funcWrapper(np.diagonal, *args, **kwargs),
    "np.mean":                    lambda *args, **kwargs: funcWrapper(np.mean, *args, **kwargs),
    "np.ndim":                    lambda *args, **kwargs: funcWrapper(np.ndim, *args, **kwargs),
    "np.nonzero":                 lambda *args, **kwargs: funcWrapper(np.nonzero, *args, **kwargs),
    "np.partition":               lambda *args, **kwargs: funcWrapper(np.partition, *args, **kwargs),
    "np.prod":                    lambda *args, **kwargs: funcWrapper(np.prod, *args, **kwargs),
    "np.product":                 lambda *args, **kwargs: funcWrapper(np.product, *args, **kwargs),
    "np.ptp":                     lambda *args, **kwargs: funcWrapper(np.ptp, *args, **kwargs),
    "np.put":                     lambda *args, **kwargs: funcWrapper(np.put, *args, **kwargs),
    "np.ravel":                   lambda *args, **kwargs: funcWrapper(np.ravel, *args, **kwargs),
    "np.repeat":                  lambda *args, **kwargs: funcWrapper(np.repeat, *args, **kwargs),
    "np.reshape":                 lambda *args, **kwargs: funcWrapper(np.reshape, *args, **kwargs),
    "np.resize":                  lambda *args, **kwargs: funcWrapper(np.resize, *args, **kwargs),
    "np.round_":                  lambda *args, **kwargs: funcWrapper(np.round_, *args, **kwargs),
    "np.searchsorted":            lambda *args, **kwargs: funcWrapper(np.searchsorted, *args, **kwargs),
    "np.shape":                   lambda *args, **kwargs: funcWrapper(np.shape, *args, **kwargs),
    "np.size":                    lambda *args, **kwargs: funcWrapper(np.size, *args, **kwargs),
    "np.sometrue":                lambda *args, **kwargs: funcWrapper(np.sometrue, *args, **kwargs),
    "np.sort":                    lambda *args, **kwargs: funcWrapper(np.sort, *args, **kwargs),
    "np.squeeze":                 lambda *args, **kwargs: funcWrapper(np.squeeze, *args, **kwargs),
    "np.std":                     lambda *args, **kwargs: funcWrapper(np.std, *args, **kwargs),
    "np.sum":                     lambda *args, **kwargs: funcWrapper(np.sum, *args, **kwargs),
    "np.swapaxes":                lambda *args, **kwargs: funcWrapper(np.swapaxes, *args, **kwargs),
    "np.take":                    lambda *args, **kwargs: funcWrapper(np.take, *args, **kwargs),
    "np.trace":                   lambda *args, **kwargs: funcWrapper(np.trace, *args, **kwargs),
    "np.transpose":               lambda *args, **kwargs: funcWrapper(np.transpose, *args, **kwargs),
    "np.absolute":                lambda *args, **kwargs: funcWrapper(np.absolute, *args, **kwargs),
    "np.add":                     lambda *args, **kwargs: funcWrapper(np.add, *args, **kwargs),
    "np.arccos":                  lambda *args, **kwargs: funcWrapper(np.arccos, *args, **kwargs),
    "np.arccosh":                 lambda *args, **kwargs: funcWrapper(np.arccosh, *args, **kwargs),
    "np.arcsin":                  lambda *args, **kwargs: funcWrapper(np.arcsin, *args, **kwargs),
    "np.arcsinh":                 lambda *args, **kwargs: funcWrapper(np.arcsinh, *args, **kwargs),
    "np.arctan":                  lambda *args, **kwargs: funcWrapper(np.arctan, *args, **kwargs),
    "np.arctan2":                 lambda *args, **kwargs: funcWrapper(np.arctan2, *args, **kwargs),
    "np.arctanh":                 lambda *args, **kwargs: funcWrapper(np.arctanh, *args, **kwargs),
    "np.bitwise_and":             lambda *args, **kwargs: funcWrapper(np.bitwise_and, *args, **kwargs),
    "np.bitwise_or":              lambda *args, **kwargs: funcWrapper(np.bitwise_or, *args, **kwargs),
    "np.bitwise_xor":             lambda *args, **kwargs: funcWrapper(np.bitwise_xor, *args, **kwargs),
    "np.cbrt":                    lambda *args, **kwargs: funcWrapper(np.cbrt, *args, **kwargs),
    "np.ceil":                    lambda *args, **kwargs: funcWrapper(np.ceil, *args, **kwargs),
    "np.conj":                    lambda *args, **kwargs: funcWrapper(np.conj, *args, **kwargs),
    "np.conjugate":               lambda *args, **kwargs: funcWrapper(np.conjugate, *args, **kwargs),
    "np.copysign":                lambda *args, **kwargs: funcWrapper(np.copysign, *args, **kwargs),
    "np.cos":                     lambda *args, **kwargs: funcWrapper(np.cos, *args, **kwargs),
    "np.cosh":                    lambda *args, **kwargs: funcWrapper(np.cosh, *args, **kwargs),
    "np.deg2rad":                 lambda *args, **kwargs: funcWrapper(np.deg2rad, *args, **kwargs),
    "np.degrees":                 lambda *args, **kwargs: funcWrapper(np.degrees, *args, **kwargs),
    "np.divide":                  lambda *args, **kwargs: funcWrapper(np.divide, *args, **kwargs),
    "np.divmod":                  lambda *args, **kwargs: funcWrapper(np.divmod, *args, **kwargs),
    "np.equal":                   lambda *args, **kwargs: funcWrapper(np.equal, *args, **kwargs),
    "np.exp":                     lambda *args, **kwargs: funcWrapper(np.exp, *args, **kwargs),
    "np.exp2":                    lambda *args, **kwargs: funcWrapper(np.exp2, *args, **kwargs),
    "np.expm1":                   lambda *args, **kwargs: funcWrapper(np.expm1, *args, **kwargs),
    "np.fabs":                    lambda *args, **kwargs: funcWrapper(np.fabs, *args, **kwargs),
    "np.floor":                   lambda *args, **kwargs: funcWrapper(np.floor, *args, **kwargs),
    "np.floor_divide":            lambda *args, **kwargs: funcWrapper(np.floor_divide, *args, **kwargs),
    "np.float_power":             lambda *args, **kwargs: funcWrapper(np.float_power, *args, **kwargs),
    "np.fmax":                    lambda *args, **kwargs: funcWrapper(np.fmax, *args, **kwargs),
    "np.fmin":                    lambda *args, **kwargs: funcWrapper(np.fmin, *args, **kwargs),
    "np.fmod":                    lambda *args, **kwargs: funcWrapper(np.fmod, *args, **kwargs),
    "np.frexp":                   lambda *args, **kwargs: funcWrapper(np.frexp, *args, **kwargs),
    "np.frompyfunc":              lambda *args, **kwargs: funcWrapper(np.frompyfunc, *args, **kwargs),
    "np.gcd":                     lambda *args, **kwargs: funcWrapper(np.gcd, *args, **kwargs),
    "np.geterrobj":               lambda *args, **kwargs: funcWrapper(np.geterrobj, *args, **kwargs),
    "np.greater":                 lambda *args, **kwargs: funcWrapper(np.greater, *args, **kwargs),
    "np.greater_equal":           lambda *args, **kwargs: funcWrapper(np.greater_equal, *args, **kwargs),
    "np.heaviside":               lambda *args, **kwargs: funcWrapper(np.heaviside, *args, **kwargs),
    "np.hypot":                   lambda *args, **kwargs: funcWrapper(np.hypot, *args, **kwargs),
    "np.invert":                  lambda *args, **kwargs: funcWrapper(np.invert, *args, **kwargs),
    "np.isfinite":                lambda *args, **kwargs: funcWrapper(np.isfinite, *args, **kwargs),
    "np.isinf":                   lambda *args, **kwargs: funcWrapper(np.isinf, *args, **kwargs),
    "np.isnan":                   lambda *args, **kwargs: funcWrapper(np.isnan, *args, **kwargs),
    "np.isnat":                   lambda *args, **kwargs: funcWrapper(np.isnat, *args, **kwargs),
    "np.lcm":                     lambda *args, **kwargs: funcWrapper(np.lcm, *args, **kwargs),
    "np.ldexp":                   lambda *args, **kwargs: funcWrapper(np.ldexp, *args, **kwargs),
    "np.left_shift":              lambda *args, **kwargs: funcWrapper(np.left_shift, *args, **kwargs),
    "np.less":                    lambda *args, **kwargs: funcWrapper(np.less, *args, **kwargs),
    "np.less_equal":              lambda *args, **kwargs: funcWrapper(np.less_equal, *args, **kwargs),
    "np.log":                     lambda *args, **kwargs: funcWrapper(np.log, *args, **kwargs),
    "np.log10":                   lambda *args, **kwargs: funcWrapper(np.log10, *args, **kwargs),
    "np.log1p":                   lambda *args, **kwargs: funcWrapper(np.log1p, *args, **kwargs),
    "np.log2":                    lambda *args, **kwargs: funcWrapper(np.log2, *args, **kwargs),
    "np.logaddexp":               lambda *args, **kwargs: funcWrapper(np.logaddexp, *args, **kwargs),
    "np.logaddexp2":              lambda *args, **kwargs: funcWrapper(np.logaddexp2, *args, **kwargs),
    "np.logical_and":             lambda *args, **kwargs: funcWrapper(np.logical_and, *args, **kwargs),
    "np.logical_not":             lambda *args, **kwargs: funcWrapper(np.logical_not, *args, **kwargs),
    "np.logical_or":              lambda *args, **kwargs: funcWrapper(np.logical_or, *args, **kwargs),
    "np.logical_xor":             lambda *args, **kwargs: funcWrapper(np.logical_xor, *args, **kwargs),
    "np.maximum":                 lambda *args, **kwargs: funcWrapper(np.maximum, *args, **kwargs),
    "np.minimum":                 lambda *args, **kwargs: funcWrapper(np.minimum, *args, **kwargs),
    "np.mod":                     lambda *args, **kwargs: funcWrapper(np.mod, *args, **kwargs),
    "np.modf":                    lambda *args, **kwargs: funcWrapper(np.modf, *args, **kwargs),
    "np.multiply":                lambda *args, **kwargs: funcWrapper(np.multiply, *args, **kwargs),
    "np.negative":                lambda *args, **kwargs: funcWrapper(np.negative, *args, **kwargs),
    "np.nextafter":               lambda *args, **kwargs: funcWrapper(np.nextafter, *args, **kwargs),
    "np.not_equal":               lambda *args, **kwargs: funcWrapper(np.not_equal, *args, **kwargs),
    "np.positive":                lambda *args, **kwargs: funcWrapper(np.positive, *args, **kwargs),
    "np.power":                   lambda *args, **kwargs: funcWrapper(np.power, *args, **kwargs),
    "np.rad2deg":                 lambda *args, **kwargs: funcWrapper(np.rad2deg, *args, **kwargs),
    "np.radians":                 lambda *args, **kwargs: funcWrapper(np.radians, *args, **kwargs),
    "np.reciprocal":              lambda *args, **kwargs: funcWrapper(np.reciprocal, *args, **kwargs),
    "np.remainder":               lambda *args, **kwargs: funcWrapper(np.remainder, *args, **kwargs),
    "np.right_shift":             lambda *args, **kwargs: funcWrapper(np.right_shift, *args, **kwargs),
    "np.rint":                    lambda *args, **kwargs: funcWrapper(np.rint, *args, **kwargs),
    "np.seterrobj":               lambda *args, **kwargs: funcWrapper(np.seterrobj, *args, **kwargs),
    "np.sign":                    lambda *args, **kwargs: funcWrapper(np.sign, *args, **kwargs),
    "np.signbit":                 lambda *args, **kwargs: funcWrapper(np.signbit, *args, **kwargs),
    "np.sin":                     lambda *args, **kwargs: funcWrapper(np.sin, *args, **kwargs),
    "np.sinh":                    lambda *args, **kwargs: funcWrapper(np.sinh, *args, **kwargs),
    "np.spacing":                 lambda *args, **kwargs: funcWrapper(np.spacing, *args, **kwargs),
    "np.sqrt":                    lambda *args, **kwargs: funcWrapper(np.sqrt, *args, **kwargs),
    "np.square":                  lambda *args, **kwargs: funcWrapper(np.square, *args, **kwargs),
    "np.subtract":                lambda *args, **kwargs: funcWrapper(np.subtract, *args, **kwargs),
    "np.tan":                     lambda *args, **kwargs: funcWrapper(np.tan, *args, **kwargs),
    "np.tanh":                    lambda *args, **kwargs: funcWrapper(np.tanh, *args, **kwargs),
    "np.true_divide":             lambda *args, **kwargs: funcWrapper(np.true_divide, *args, **kwargs),
    "np.trunc":                   lambda *args, **kwargs: funcWrapper(np.trunc, *args, **kwargs),
    "np.obj2sctype":              lambda *args, **kwargs: funcWrapper(np.obj2sctype, *args, **kwargs),
    "np.sctype2char":             lambda *args, **kwargs: funcWrapper(np.sctype2char, *args, **kwargs),
    "np.maximum_sctype":          lambda *args, **kwargs: funcWrapper(np.maximum_sctype, *args, **kwargs),
    "np.issctype":                lambda *args, **kwargs: funcWrapper(np.issctype, *args, **kwargs),
    "np.find_common_type":        lambda *args, **kwargs: funcWrapper(np.find_common_type, *args, **kwargs),
    "np.issubdtype":              lambda *args, **kwargs: funcWrapper(np.issubdtype, *args, **kwargs),
    "np.datetime_data":           lambda *args, **kwargs: funcWrapper(np.datetime_data, *args, **kwargs),
    "np.datetime_as_string":      lambda *args, **kwargs: funcWrapper(np.datetime_as_string, *args, **kwargs),
    "np.busday_offset":           lambda *args, **kwargs: funcWrapper(np.busday_offset, *args, **kwargs),
    "np.busday_count":            lambda *args, **kwargs: funcWrapper(np.busday_count, *args, **kwargs),
    "np.is_busday":               lambda *args, **kwargs: funcWrapper(np.is_busday, *args, **kwargs),
    "np.busdaycalendar":          lambda *args, **kwargs: funcWrapper(np.busdaycalendar, *args, **kwargs),
    "np.byte":                    lambda *args, **kwargs: funcWrapper(np.byte, *args, **kwargs),
    "np.ubyte":                   lambda *args, **kwargs: funcWrapper(np.ubyte, *args, **kwargs),
    "np.short":                   lambda *args, **kwargs: funcWrapper(np.short, *args, **kwargs),
    "np.ushort":                  lambda *args, **kwargs: funcWrapper(np.ushort, *args, **kwargs),
    "np.uint":                    lambda *args, **kwargs: funcWrapper(np.uint, *args, **kwargs),
    "np.intp":                    lambda *args, **kwargs: funcWrapper(np.intp, *args, **kwargs),
    "np.uintp":                   lambda *args, **kwargs: funcWrapper(np.uintp, *args, **kwargs),
    "np.longlong":                lambda *args, **kwargs: funcWrapper(np.longlong, *args, **kwargs),
    "np.ulonglong":               lambda *args, **kwargs: funcWrapper(np.ulonglong, *args, **kwargs),
    "np.half":                    lambda *args, **kwargs: funcWrapper(np.half, *args, **kwargs),
    "np.double":                  lambda *args, **kwargs: funcWrapper(np.double, *args, **kwargs),
    "np.longdouble":              lambda *args, **kwargs: funcWrapper(np.longdouble, *args, **kwargs),
    "np.cfloat":                  lambda *args, **kwargs: funcWrapper(np.cfloat, *args, **kwargs),
    "np.cdouble":                 lambda *args, **kwargs: funcWrapper(np.cdouble, *args, **kwargs),
    "np.clongdouble":             lambda *args, **kwargs: funcWrapper(np.clongdouble, *args, **kwargs),
    "np.void":                    lambda *args, **kwargs: funcWrapper(np.void, *args, **kwargs),
    "np.generic":                 lambda *args, **kwargs: funcWrapper(np.generic, *args, **kwargs),
    "np.number":                  lambda *args, **kwargs: funcWrapper(np.number, *args, **kwargs),
    "np.integer":                 lambda *args, **kwargs: funcWrapper(np.integer, *args, **kwargs),
    "np.inexact":                 lambda *args, **kwargs: funcWrapper(np.inexact, *args, **kwargs),
    "np.signedinteger":           lambda *args, **kwargs: funcWrapper(np.signedinteger, *args, **kwargs),
    "np.unsignedinteger":         lambda *args, **kwargs: funcWrapper(np.unsignedinteger, *args, **kwargs),
    "np.floating":                lambda *args, **kwargs: funcWrapper(np.floating, *args, **kwargs),
    "np.complexfloating":         lambda *args, **kwargs: funcWrapper(np.complexfloating, *args, **kwargs),
    "np.flexible":                lambda *args, **kwargs: funcWrapper(np.flexible, *args, **kwargs),
    "np.character":               lambda *args, **kwargs: funcWrapper(np.character, *args, **kwargs),
    "np.bool8":                   lambda *args, **kwargs: funcWrapper(np.bool8, *args, **kwargs),
    "np.int64":                   lambda *args, **kwargs: funcWrapper(np.int64, *args, **kwargs),
    "np.uint64":                  lambda *args, **kwargs: funcWrapper(np.uint64, *args, **kwargs),
    "np.float16":                 lambda *args, **kwargs: funcWrapper(np.float16, *args, **kwargs),
    "np.float32":                 lambda *args, **kwargs: funcWrapper(np.float32, *args, **kwargs),
    "np.float64":                 lambda *args, **kwargs: funcWrapper(np.float64, *args, **kwargs),
    "np.float128":                lambda *args, **kwargs: funcWrapper(np.float128, *args, **kwargs),
    "np.complex64":               lambda *args, **kwargs: funcWrapper(np.complex64, *args, **kwargs),
    "np.complex128":              lambda *args, **kwargs: funcWrapper(np.complex128, *args, **kwargs),
    "np.complex256":              lambda *args, **kwargs: funcWrapper(np.complex256, *args, **kwargs),
    "np.object0":                 lambda *args, **kwargs: funcWrapper(np.object0, *args, **kwargs),
    "np.bytes0":                  lambda *args, **kwargs: funcWrapper(np.bytes0, *args, **kwargs),
    "np.str0":                    lambda *args, **kwargs: funcWrapper(np.str0, *args, **kwargs),
    "np.void0":                   lambda *args, **kwargs: funcWrapper(np.void0, *args, **kwargs),
    "np.datetime64":              lambda *args, **kwargs: funcWrapper(np.datetime64, *args, **kwargs),
    "np.timedelta64":             lambda *args, **kwargs: funcWrapper(np.timedelta64, *args, **kwargs),
    "np.int32":                   lambda *args, **kwargs: funcWrapper(np.int32, *args, **kwargs),
    "np.uint32":                  lambda *args, **kwargs: funcWrapper(np.uint32, *args, **kwargs),
    "np.int16":                   lambda *args, **kwargs: funcWrapper(np.int16, *args, **kwargs),
    "np.uint16":                  lambda *args, **kwargs: funcWrapper(np.uint16, *args, **kwargs),
    "np.int8":                    lambda *args, **kwargs: funcWrapper(np.int8, *args, **kwargs),
    "np.uint8":                   lambda *args, **kwargs: funcWrapper(np.uint8, *args, **kwargs),
    "np.int0":                    lambda *args, **kwargs: funcWrapper(np.int0, *args, **kwargs),
    "np.uint0":                   lambda *args, **kwargs: funcWrapper(np.uint0, *args, **kwargs),
    "np.single":                  lambda *args, **kwargs: funcWrapper(np.single, *args, **kwargs),
    "np.csingle":                 lambda *args, **kwargs: funcWrapper(np.csingle, *args, **kwargs),
    "np.singlecomplex":           lambda *args, **kwargs: funcWrapper(np.singlecomplex, *args, **kwargs),
    "np.intc":                    lambda *args, **kwargs: funcWrapper(np.intc, *args, **kwargs),
    "np.uintc":                   lambda *args, **kwargs: funcWrapper(np.uintc, *args, **kwargs),
    "np.longfloat":               lambda *args, **kwargs: funcWrapper(np.longfloat, *args, **kwargs),
    "np.clongfloat":              lambda *args, **kwargs: funcWrapper(np.clongfloat, *args, **kwargs),
    "np.longcomplex":             lambda *args, **kwargs: funcWrapper(np.longcomplex, *args, **kwargs),
    "np.array2string":            lambda *args, **kwargs: funcWrapper(np.array2string, *args, **kwargs),
    "np.array_str":               lambda *args, **kwargs: funcWrapper(np.array_str, *args, **kwargs),
    "np.array_repr":              lambda *args, **kwargs: funcWrapper(np.array_repr, *args, **kwargs),
    "np.format_float_positional": lambda *args, **kwargs: funcWrapper(np.format_float_positional, *args, **kwargs),
    "np.format_float_scientific": lambda *args, **kwargs: funcWrapper(np.format_float_scientific, *args, **kwargs),
    "np.require":                 lambda *args, **kwargs: funcWrapper(np.require, *args, **kwargs),
    "np.seterr":                  lambda *args, **kwargs: funcWrapper(np.seterr, *args, **kwargs),
    "np.geterr":                  lambda *args, **kwargs: funcWrapper(np.geterr, *args, **kwargs),
    "np.setbufsize":              lambda *args, **kwargs: funcWrapper(np.setbufsize, *args, **kwargs),
    "np.getbufsize":              lambda *args, **kwargs: funcWrapper(np.getbufsize, *args, **kwargs),
    "np.seterrcall":              lambda *args, **kwargs: funcWrapper(np.seterrcall, *args, **kwargs),
    "np.geterrcall":              lambda *args, **kwargs: funcWrapper(np.geterrcall, *args, **kwargs),
    "np.errstate":                lambda *args, **kwargs: funcWrapper(np.errstate, *args, **kwargs),
    "np.record":                  lambda *args, **kwargs: funcWrapper(np.record, *args, **kwargs),
    "np.recarray":                lambda *args, **kwargs: funcWrapper(np.recarray, *args, **kwargs),
    "np.format_parser":           lambda *args, **kwargs: funcWrapper(np.format_parser, *args, **kwargs),
    "np.chararray":               lambda *args, **kwargs: funcWrapper(np.chararray, *args, **kwargs),
    "np.logspace":                lambda *args, **kwargs: funcWrapper(np.logspace, *args, **kwargs),
    "np.linspace":                lambda *args, **kwargs: funcWrapper(np.linspace, *args, **kwargs),
    "np.geomspace":               lambda *args, **kwargs: funcWrapper(np.geomspace, *args, **kwargs),
    "np.atleast_1d":              lambda *args, **kwargs: funcWrapper(np.atleast_1d, *args, **kwargs),
    "np.atleast_2d":              lambda *args, **kwargs: funcWrapper(np.atleast_2d, *args, **kwargs),
    "np.atleast_3d":              lambda *args, **kwargs: funcWrapper(np.atleast_3d, *args, **kwargs),
    "np.block":                   lambda *args, **kwargs: funcWrapper(np.block, *args, **kwargs),
    "np.hstack":                  lambda *args, **kwargs: funcWrapper(np.hstack, *args, **kwargs),
    "np.stack":                   lambda *args, **kwargs: funcWrapper(np.stack, *args, **kwargs),
    "np.vstack":                  lambda *args, **kwargs: funcWrapper(np.vstack, *args, **kwargs),
    "np.einsum":                  lambda *args, **kwargs: funcWrapper(np.einsum, *args, **kwargs),
    "np.einsum_path":             lambda *args, **kwargs: funcWrapper(np.einsum_path, *args, **kwargs),
    "np.iscomplexobj":            lambda *args, **kwargs: funcWrapper(np.iscomplexobj, *args, **kwargs),
    "np.isrealobj":               lambda *args, **kwargs: funcWrapper(np.isrealobj, *args, **kwargs),
    "np.imag":                    lambda *args, **kwargs: funcWrapper(np.imag, *args, **kwargs),
    "np.iscomplex":               lambda *args, **kwargs: funcWrapper(np.iscomplex, *args, **kwargs),
    "np.isreal":                  lambda *args, **kwargs: funcWrapper(np.isreal, *args, **kwargs),
    "np.real":                    lambda *args, **kwargs: funcWrapper(np.real, *args, **kwargs),
    "np.real_if_close":           lambda *args, **kwargs: funcWrapper(np.real_if_close, *args, **kwargs),
    "np.asfarray":                lambda *args, **kwargs: funcWrapper(np.asfarray, *args, **kwargs),
    "np.ravel_multi_index":       lambda *args, **kwargs: funcWrapper(np.ravel_multi_index, *args, **kwargs),
    "np.unravel_index":           lambda *args, **kwargs: funcWrapper(np.unravel_index, *args, **kwargs),
    "np.ix_":                     lambda *args, **kwargs: funcWrapper(np.ix_, *args, **kwargs),
    "np.ndenumerate":             lambda *args, **kwargs: funcWrapper(np.ndenumerate, *args, **kwargs),
    "np.ndindex":                 lambda *args, **kwargs: funcWrapper(np.ndindex, *args, **kwargs),
    "np.fill_diagonal":           lambda *args, **kwargs: funcWrapper(np.fill_diagonal, *args, **kwargs),
    "np.diag_indices":            lambda *args, **kwargs: funcWrapper(np.diag_indices, *args, **kwargs),
    "np.diag_indices_from":       lambda *args, **kwargs: funcWrapper(np.diag_indices_from, *args, **kwargs),
    "np.select":                  lambda *args, **kwargs: funcWrapper(np.select, *args, **kwargs),
    "np.piecewise":               lambda *args, **kwargs: funcWrapper(np.piecewise, *args, **kwargs),
    "np.trim_zeros":              lambda *args, **kwargs: funcWrapper(np.trim_zeros, *args, **kwargs),
    "np.copy":                    lambda *args, **kwargs: funcWrapper(np.copy, *args, **kwargs),
    "np.iterable":                lambda *args, **kwargs: funcWrapper(np.iterable, *args, **kwargs),
    "np.percentile":              lambda *args, **kwargs: funcWrapper(np.percentile, *args, **kwargs),
    "np.diff":                    lambda *args, **kwargs: funcWrapper(np.diff, *args, **kwargs),
    "np.gradient":                lambda *args, **kwargs: funcWrapper(np.gradient, *args, **kwargs),
    "np.angle":                   lambda *args, **kwargs: funcWrapper(np.angle, *args, **kwargs),
    "np.unwrap":                  lambda *args, **kwargs: funcWrapper(np.unwrap, *args, **kwargs),
    "np.sort_complex":            lambda *args, **kwargs: funcWrapper(np.sort_complex, *args, **kwargs),
    "np.disp":                    lambda *args, **kwargs: funcWrapper(np.disp, *args, **kwargs),
    "np.flip":                    lambda *args, **kwargs: funcWrapper(np.flip, *args, **kwargs),
    "np.rot90":                   lambda *args, **kwargs: funcWrapper(np.rot90, *args, **kwargs),
    "np.extract":                 lambda *args, **kwargs: funcWrapper(np.extract, *args, **kwargs),
    "np.place":                   lambda *args, **kwargs: funcWrapper(np.place, *args, **kwargs),
    "np.vectorize":               lambda *args, **kwargs: funcWrapper(np.vectorize, *args, **kwargs),
    "np.asarray_chkfinite":       lambda *args, **kwargs: funcWrapper(np.asarray_chkfinite, *args, **kwargs),
    "np.average":                 lambda *args, **kwargs: funcWrapper(np.average, *args, **kwargs),
    "np.bincount":                lambda *args, **kwargs: funcWrapper(np.bincount, *args, **kwargs),
    "np.digitize":                lambda *args, **kwargs: funcWrapper(np.digitize, *args, **kwargs),
    "np.cov":                     lambda *args, **kwargs: funcWrapper(np.cov, *args, **kwargs),
    "np.corrcoef":                lambda *args, **kwargs: funcWrapper(np.corrcoef, *args, **kwargs),
    "np.msort":                   lambda *args, **kwargs: funcWrapper(np.msort, *args, **kwargs),
    "np.median":                  lambda *args, **kwargs: funcWrapper(np.median, *args, **kwargs),
    "np.sinc":                    lambda *args, **kwargs: funcWrapper(np.sinc, *args, **kwargs),
    "np.hamming":                 lambda *args, **kwargs: funcWrapper(np.hamming, *args, **kwargs),
    "np.hanning":                 lambda *args, **kwargs: funcWrapper(np.hanning, *args, **kwargs),
    "np.bartlett":                lambda *args, **kwargs: funcWrapper(np.bartlett, *args, **kwargs),
    "np.blackman":                lambda *args, **kwargs: funcWrapper(np.blackman, *args, **kwargs),
    "np.kaiser":                  lambda *args, **kwargs: funcWrapper(np.kaiser, *args, **kwargs),
    "np.trapz":                   lambda *args, **kwargs: funcWrapper(np.trapz, *args, **kwargs),
    "np.i0":                      lambda *args, **kwargs: funcWrapper(np.i0, *args, **kwargs),
    "np.add_newdoc":              lambda *args, **kwargs: funcWrapper(np.add_newdoc, *args, **kwargs),
    "np.add_docstring":           lambda *args, **kwargs: funcWrapper(np.add_docstring, *args, **kwargs),
    "np.meshgrid":                lambda *args, **kwargs: funcWrapper(np.meshgrid, *args, **kwargs),
    "np.delete":                  lambda *args, **kwargs: funcWrapper(np.delete, *args, **kwargs),
    "np.insert":                  lambda *args, **kwargs: funcWrapper(np.insert, *args, **kwargs),
    "np.append":                  lambda *args, **kwargs: funcWrapper(np.append, *args, **kwargs),
    "np.interp":                  lambda *args, **kwargs: funcWrapper(np.interp, *args, **kwargs),
    "np.add_newdoc_ufunc":        lambda *args, **kwargs: funcWrapper(np.add_newdoc_ufunc, *args, **kwargs),
    "np.quantile":                lambda *args, **kwargs: funcWrapper(np.quantile, *args, **kwargs),
    "np.column_stack":            lambda *args, **kwargs: funcWrapper(np.column_stack, *args, **kwargs),
    "np.row_stack":               lambda *args, **kwargs: funcWrapper(np.row_stack, *args, **kwargs),
    "np.dstack":                  lambda *args, **kwargs: funcWrapper(np.dstack, *args, **kwargs),
    "np.array_split":             lambda *args, **kwargs: funcWrapper(np.array_split, *args, **kwargs),
    "np.split":                   lambda *args, **kwargs: funcWrapper(np.split, *args, **kwargs),
    "np.hsplit":                  lambda *args, **kwargs: funcWrapper(np.hsplit, *args, **kwargs),
    "np.vsplit":                  lambda *args, **kwargs: funcWrapper(np.vsplit, *args, **kwargs),
    "np.dsplit":                  lambda *args, **kwargs: funcWrapper(np.dsplit, *args, **kwargs),
    "np.apply_over_axes":         lambda *args, **kwargs: funcWrapper(np.apply_over_axes, *args, **kwargs),
    "np.expand_dims":             lambda *args, **kwargs: funcWrapper(np.expand_dims, *args, **kwargs),
    "np.apply_along_axis":        lambda *args, **kwargs: funcWrapper(np.apply_along_axis, *args, **kwargs),
    "np.kron":                    lambda *args, **kwargs: funcWrapper(np.kron, *args, **kwargs),
    "np.tile":                    lambda *args, **kwargs: funcWrapper(np.tile, *args, **kwargs),
    "np.get_array_wrap":          lambda *args, **kwargs: funcWrapper(np.get_array_wrap, *args, **kwargs),
    "np.take_along_axis":         lambda *args, **kwargs: funcWrapper(np.take_along_axis, *args, **kwargs),
    "np.put_along_axis":          lambda *args, **kwargs: funcWrapper(np.put_along_axis, *args, **kwargs),
    "np.broadcast_to":            lambda *args, **kwargs: funcWrapper(np.broadcast_to, *args, **kwargs),
    "np.broadcast_arrays":        lambda *args, **kwargs: funcWrapper(np.broadcast_arrays, *args, **kwargs),
    "np.broadcast_shapes":        lambda *args, **kwargs: funcWrapper(np.broadcast_shapes, *args, **kwargs),
    "np.diag":                    lambda *args, **kwargs: funcWrapper(np.diag, *args, **kwargs),
    "np.diagflat":                lambda *args, **kwargs: funcWrapper(np.diagflat, *args, **kwargs),
    "np.eye":                     lambda *args, **kwargs: funcWrapper(np.eye, *args, **kwargs),
    "np.fliplr":                  lambda *args, **kwargs: funcWrapper(np.fliplr, *args, **kwargs),
    "np.flipud":                  lambda *args, **kwargs: funcWrapper(np.flipud, *args, **kwargs),
    "np.tri":                     lambda *args, **kwargs: funcWrapper(np.tri, *args, **kwargs),
    "np.triu":                    lambda *args, **kwargs: funcWrapper(np.triu, *args, **kwargs),
    "np.tril":                    lambda *args, **kwargs: funcWrapper(np.tril, *args, **kwargs),
    "np.vander":                  lambda *args, **kwargs: funcWrapper(np.vander, *args, **kwargs),
    "np.mask_indices":            lambda *args, **kwargs: funcWrapper(np.mask_indices, *args, **kwargs),
    "np.tril_indices":            lambda *args, **kwargs: funcWrapper(np.tril_indices, *args, **kwargs),
    "np.tril_indices_from":       lambda *args, **kwargs: funcWrapper(np.tril_indices_from, *args, **kwargs),
    "np.triu_indices":            lambda *args, **kwargs: funcWrapper(np.triu_indices, *args, **kwargs),
    "np.triu_indices_from":       lambda *args, **kwargs: funcWrapper(np.triu_indices_from, *args, **kwargs),
    "np.fix":                     lambda *args, **kwargs: funcWrapper(np.fix, *args, **kwargs),
    "np.isneginf":                lambda *args, **kwargs: funcWrapper(np.isneginf, *args, **kwargs),
    "np.isposinf":                lambda *args, **kwargs: funcWrapper(np.isposinf, *args, **kwargs),
    "np.pad":                     lambda *args, **kwargs: funcWrapper(np.pad, *args, **kwargs),
    "np.poly":                    lambda *args, **kwargs: funcWrapper(np.poly, *args, **kwargs),
    "np.roots":                   lambda *args, **kwargs: funcWrapper(np.roots, *args, **kwargs),
    "np.polyint":                 lambda *args, **kwargs: funcWrapper(np.polyint, *args, **kwargs),
    "np.polyder":                 lambda *args, **kwargs: funcWrapper(np.polyder, *args, **kwargs),
    "np.polyadd":                 lambda *args, **kwargs: funcWrapper(np.polyadd, *args, **kwargs),
    "np.polysub":                 lambda *args, **kwargs: funcWrapper(np.polysub, *args, **kwargs),
    "np.polymul":                 lambda *args, **kwargs: funcWrapper(np.polymul, *args, **kwargs),
    "np.polydiv":                 lambda *args, **kwargs: funcWrapper(np.polydiv, *args, **kwargs),
    "np.polyval":                 lambda *args, **kwargs: funcWrapper(np.polyval, *args, **kwargs),
    "np.poly1d":                  lambda *args, **kwargs: funcWrapper(np.poly1d, *args, **kwargs),
    "np.polyfit":                 lambda *args, **kwargs: funcWrapper(np.polyfit, *args, **kwargs),
    "np.ediff1d":                 lambda *args, **kwargs: funcWrapper(np.ediff1d, *args, **kwargs),
    "np.intersect1d":             lambda *args, **kwargs: funcWrapper(np.intersect1d, *args, **kwargs),
    "np.setxor1d":                lambda *args, **kwargs: funcWrapper(np.setxor1d, *args, **kwargs),
    "np.union1d":                 lambda *args, **kwargs: funcWrapper(np.union1d, *args, **kwargs),
    "np.setdiff1d":               lambda *args, **kwargs: funcWrapper(np.setdiff1d, *args, **kwargs),
    "np.unique":                  lambda *args, **kwargs: funcWrapper(np.unique, *args, **kwargs),
    "np.in1d":                    lambda *args, **kwargs: funcWrapper(np.in1d, *args, **kwargs),
    "np.isin":                    lambda *args, **kwargs: funcWrapper(np.isin, *args, **kwargs),
    "np.packbits":                lambda *args, **kwargs: funcWrapper(np.packbits, *args, **kwargs),
    "np.unpackbits":              lambda *args, **kwargs: funcWrapper(np.unpackbits, *args, **kwargs),
    "np.matrix":                  lambda *args, **kwargs: funcWrapper(np.matrix, *args, **kwargs),
    "np.bmat":                    lambda *args, **kwargs: funcWrapper(np.bmat, *args, **kwargs),
    "np.mat":                     lambda *args, **kwargs: funcWrapper(np.mat, *args, **kwargs),
    "np.asmatrix":                lambda *args, **kwargs: funcWrapper(np.asmatrix, *args, **kwargs),
    "np.round":                   lambda *args, **kwargs: funcWrapper(np.round, *args, **kwargs),
    "np.abs":                     lambda *args, **kwargs: funcWrapper(np.abs, *args, **kwargs),
    "np.max":                     lambda *args, **kwargs: funcWrapper(np.max, *args, **kwargs),
    "np.min":                     lambda *args, **kwargs: funcWrapper(np.min, *args, **kwargs),


    #np linear algebra functions
    "linalg.matrix_power": lambda *args, **kwargs: funcWrapper(np.linalg.matrix_power, *args, **kwargs),
    "linalg.solve":        lambda *args, **kwargs: funcWrapper(np.linalg.solve, *args, **kwargs),
    "linalg.tensorsolve":  lambda *args, **kwargs: funcWrapper(np.linalg.tensorsolve, *args, **kwargs),
    "linalg.tensorinv":    lambda *args, **kwargs: funcWrapper(np.linalg.tensorinv, *args, **kwargs),
    "linalg.inv":          lambda *args, **kwargs: funcWrapper(np.linalg.inv, *args, **kwargs),
    "linalg.cholesky":     lambda *args, **kwargs: funcWrapper(np.linalg.cholesky, *args, **kwargs),
    "linalg.eigvals":      lambda *args, **kwargs: funcWrapper(np.linalg.eigvals, *args, **kwargs),
    "linalg.eigvalsh":     lambda *args, **kwargs: funcWrapper(np.linalg.eigvalsh, *args, **kwargs),
    "linalg.pinv":         lambda *args, **kwargs: funcWrapper(np.linalg.pinv, *args, **kwargs),
    "linalg.slogdet":      lambda *args, **kwargs: funcWrapper(np.linalg.slogdet, *args, **kwargs),
    "linalg.det":          lambda *args, **kwargs: funcWrapper(np.linalg.det, *args, **kwargs),
    "linalg.svd":          lambda *args, **kwargs: funcWrapper(np.linalg.svd, *args, **kwargs),
    "linalg.eig":          lambda *args, **kwargs: funcWrapper(np.linalg.eig, *args, **kwargs),
    "linalg.eigh":         lambda *args, **kwargs: funcWrapper(np.linalg.eigh, *args, **kwargs),
    "linalg.lstsq":        lambda *args, **kwargs: funcWrapper(np.linalg.lstsq, *args, **kwargs),
    "linalg.norm":         lambda *args, **kwargs: funcWrapper(np.linalg.norm, *args, **kwargs),
    "linalg.qr":           lambda *args, **kwargs: funcWrapper(np.linalg.qr, *args, **kwargs),
    "linalg.cond":         lambda *args, **kwargs: funcWrapper(np.linalg.cond, *args, **kwargs),
    "linalg.matrix_rank":  lambda *args, **kwargs: funcWrapper(np.linalg.matrix_rank, *args, **kwargs),
    "linalg.multi_dot":    lambda *args, **kwargs: funcWrapper(np.linalg.multi_dot, *args, **kwargs),
    "linalg.test":         lambda *args, **kwargs: funcWrapper(np.linalg.test, *args, **kwargs),
}

def evaluate(expression):
    code = compile(expression, "<string>", "eval")

    for name in code.co_names:
        if name not in allowedNames:
            raise NameError(f"Unknown Name: '{name}'")
    return eval(code, {"__builtins__": {}}, allowedNames)



def padZeros(s, numDigits):
    return str(s).zfill(numDigits)

numLinesInErrorMessage = 5
def formatError(lines: list, lineNum: int, errorName: str, errorInfo: str):
    errorMessage = f"{errorName}: {errorInfo}"

    startIndex = max(int(lineNum - ((numLinesInErrorMessage - 1) / 2)), 0)
    endIndex = min(startIndex + numLinesInErrorMessage, len(lines))

    numDigits = len(str(endIndex - 1))

    for i in range(startIndex, lineNum):
        errorMessage += f"\n    {padZeros(i, numDigits)}: {lines[i]}"

    errorMessage += f"\n>>> {padZeros(lineNum, numDigits)}: {lines[lineNum]}"

    for i in range(lineNum + 1, endIndex):
        errorMessage += f"\n    {padZeros(i, numDigits)}: {lines[i]}"

    return errorMessage


def InvalidOperationError(lines, lineNum, op):
    return formatError(lines, lineNum, "InvalidOperation", op)

def NumArgumentsError(lines, lineNum, op, numArgsGiven, numRequiredMin, numRequiredMax = -1):
    if numRequiredMax < numRequiredMin:
        return formatError(lines, lineNum, "NumArgumentsError", f"operation: {op} requires {numRequiredMin}-{numRequiredMax} arguments ({numArgsGiven} given)")
    return formatError(lines, lineNum, "NumArgumentsError", f"operation: {op} requires {numRequiredMin} argument(s) ({numArgsGiven} given)")

# operations
def cjmp(lineNum, tokens):
    raise NotImplementedError()

def qjmp(lineNum, tokens):
    raise NotImplementedError()

def cdef(lineNum, tokens):
    if len(tokens) != 3:
        raise
    raise NotImplementedError()

def qdef(lineNum, tokens):
    raise NotImplementedError()

def gate(lineNum, tokens):
    raise NotImplementedError()

def perm(lineNum, tokens):
    raise NotImplementedError()

def meas(lineNum, tokens):
    raise NotImplementedError()

def mark(lineNum, tokens):
    raise NotImplementedError()

def note(lineNum, tokens):
    raise NotImplementedError()

operations = {
    'cjmp': cjmp,
    'qjmp': qjmp,
    'cdef': cdef,
    'qdef': qdef,
    'gate': gate,
    'perm': perm,
    'meas': meas,
    'mark': mark,
    'note': note,
    'cout': note,
}
